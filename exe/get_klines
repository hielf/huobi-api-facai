#!/usr/bin/env ruby

require "bundler/setup"
require 'huobi_api'
require 'async'
require 'gdbm'
require 'oj'
require 'json'
require 'multi_json'
require 'optparse'

module HuobiApi
  module Network
    module WebSocket
      class ReqKLine
        # 获取币的K线起始时间点(多数情况下也即该币上线交易的时间点)
        # 获取到的时间将以'btcusdt: 1212121212'格式写入文件kline_start_time.txt
        def self.kline_start_at(symbol)
          # 先从文件中查询
          path = File.absolute_path(__dir__) + "/" + 'kline_start_time.txt'
          if File.exist?(path)
            File.readlines(path, chomp: true).each do |line|
              info = MultiJson.load(line)
              return info if info["symbol"] == symbol
            end
          end

          tmp_data = []
          cnt = 900 # 每次获取900根K线

          # 新建一个临时ws
          cbs = {
            on_open: ->(event) {
              ws = event.current_target
              Log.debug(self.class) { "ws connected：#{ws.url}" }
            },
            on_close: ->(_event) { Log.debug(self.class) { "ws closed" } },
            on_error: ->(_event) {},
            on_message: ->(event) {
              ws = event.current_target
              blob_arr = event.data
              data = MultiJson.load(Zlib::gunzip(blob_arr.pack('c*')), symbolize_keys: true)

              case data
              in { ping: ts }
                ws.opened? && ws.send(MultiJson.dump({ "pong": ts }))
              in { id:, rep:, status: 'ok', data: Array }
                tmp_data << data
              else
                Log.debug(self.class) { "other msgs: #{data}" }
              end
            }
          }
          url = WS_URLS[0] + '/ws'
          ws = WebSocket.new_ws(url, **cbs).wait_opened

          get_res = ->(req) {
            ws.send(req)

            Async do |subtask|
              subtask.sleep 0.05 until tmp_data.any?
              tmp_data.shift[:data]
            end.wait
          }

          # 找到从哪一周开始
          find_week = ->(to = Time.now.to_i) {
            req = gen_req(symbol, '1week', to: to)
            data = get_res.call(req)
            if data.size < cnt
              data[0][:id]
            elsif data.size == cnt
              to = data[0][:id] - 1
              find_week.call(to = to)
            end
          }

          # 找到起始周后，从起始周开始找到起始时间点
          find_epoch = ->(from, type) {
            req = gen_req(symbol, type, from: from)
            data = get_res.call(req)
            if data.empty?
              from += cnt * distance(type)
              find_epoch.call(from, type)
            elsif data.size < cnt
              data[0][:id]
            elsif data.size == cnt
              from = from - cnt * distance(type) + 1
              find_epoch.call(from, type)
            end
          }

          epoch_week = find_week.call
          epoch_day = find_epoch.call(epoch_week, '1day')
          epoch_60min = find_epoch.call(epoch_day, '60min')
          epoch_30min = find_epoch.call(epoch_60min, '30min')
          epoch_15min = find_epoch.call(epoch_30min, '15min')
          epoch_5min = find_epoch.call(epoch_15min, '5min')

          ts = {
            "symbol" => symbol,
            "1week" => epoch_week,
            "1day" => epoch_day,
            "60min" => epoch_60min,
            "30min" => epoch_30min,
            "15min" => epoch_15min,
            "5min" => epoch_5min,
            "1min" => epoch_5min,
          }
          ws.close

          File.open(path, 'a') do |f|
            f.puts JSON.dump(ts)
          end

          ts
        end

        # 查找一个或多个币的K线起始时间点
        # @param symbols 数组
        # @return {btcusdt: 12121212, ethusdt: 213232323,...}
        def self.klines_start_at(symbols)
          times = []

          # 最大并发64个查询
          symbols.each_slice(64).each do |some_coins|
            Async(annotation: 'klines_start_at: control concurrent count') do |task|
              some_coins.each do |symbol|
                Async(annotation: 'call kline_start_at') do |subtask|
                  times << kline_start_at(symbol)
                end
              end
            end
          end

          times
        end

        # 生成某币某个K线类型的所有请求(从最早的第一根K线到目前为止，每个请求获取900根K线)
        # @param type '1min', '5min', '15min', '30min', '60min', '1day', '1week'
        def self.gen_coin_all_reqs(symbol, type, from: nil)
          cnt = 900
          start_time = (from || kline_start_at(symbol)[type])
          # start_time = (from || kline_epoch_align(type, kline_start_at(symbol)[type]))

          (start_time..Time.now.to_i)
            .step(cnt * distance(type))
            .map { |f| gen_req(symbol, type, from: f) }
        end

        def gen_coin_all_reqs(...)
          self.class.gen_coin_all_reqs(...)
        end

      end
    end
  end
end

class KlinesDB
  class DB
    attr_reader :db

    # 每个币的每种类型一个dbm文件，例如btcusdt_1min一个db文件，btcusdt_5min一个db文件
    # 每次请求获得的(最多)每900根K线作为一个dbm Key/Value，其key为这最多900根K线的起始epoch
    # @param mode 打开GDBM的标记，当值为r时表示只读打开，其他任何值都表示默认的写打开
    def initialize(symbol, type, mode = nil)
      @symbol = symbol
      @type = type
      @cnt = 900 # 一次尽量且最多存放900根K线

      db_dir = "/mnt/v/huobi_klines"
      File.directory?(db_dir) || Dir.mkdir(db_dir)
      @file_name = "#{symbol}_#{type}"

      mode = (mode == 'r' ? GDBM::READER : GDBM::WRCREAT)
      @db = GDBM.new("#{db_dir}/#{@file_name}", 0666, mode)
    end

    def self.open(symbol, type, mode = 'r')
      db = new(symbol, type)
      return db unless block_given?

      begin
        yield db
      ensure
        db.close
      end
    end

    def save(epoch, klines)
      db[epoch.to_s] = MultiJson.dump(klines)
    end

    def keys = db.keys

    def [](idx)
      tmp = db[idx.to_s]
      tmp.nil? ? nil : MultiJson.load(tmp, symbolize_keys: true)
    end

    def []=(k, v)
      # Oj的dump效率低，因此使用json标准库来dump
      db[k.to_s] = MultiJson.dump(v)
    end

    def get(epoch)
      return nil unless Numeric === epoch

      hash = db.find do |k, _|
        epoch >= k.to_i and epoch < (k.to_i + @cnt * distance(@type))
      end

      return nil if hash.nil?

      MultiJson.load(hash[1], symbolize_keys: true)
    end

    def self.get(symbol, type, epoch)
      db = new(symbol, type)
      data = db.get(epoch)
      db.close

      return data unless block_given?
      yield data
    end

    def get_all
      h = {}
      db.keys.sort_by(&:to_i).each do |key|
        h[key.to_i] = MultiJson.load(db[key], symbolize_keys: true)
      end
      h
    end

    def self.get_all(symbol, type)
      db = new(symbol, type)
      data = db.get_all
      db.close

      return data unless block_given?
      yield data
    end

    def close = db.close

    private def distance(type)
      case type
      when '1min' then
        60 # 60
      when '5min' then
        300 # 5 * 60
      when '15min' then
        900 # 15 * 60
      when '30min' then
        1800 # 30 * 60
      when '60min' then
        3600 # 60 * 60
      when '1day' then
        86400 # 24 * 60 * 60
      when '1week' then
        604800 # 7 * 24 * 60 * 60
      end
    end
  end

  def self.fetch_klines(symbol_or_arr, type = nil, conn_size = nil)
    kline_db = self.new(conn_size)
    kline_db.fetch_klines(symbol_or_arr, type)
  end

  attr_reader :kline, :klines, :dispatche_thread

  def initialize(pool_size = nil)
    @kline = HuobiApi::Network::WebSocket::ReqKLine.new(pool_size || 90)

    # 每个币的每种类型一个dbm文件，例如btcusdt_1min一个db文件，btcusdt_5min一个db文件
    # 每次请求获得的(最多)每900根K线作为一个dbm Key/Value，其key为这最多900根K线的起始epoch
    # @klines = {
    #   'btcusdt_1min': { epoch1: [klines], epoch2: [klines]},
    #   'btcusdt_5min': { epoch1: [klines], epoch2: [klines]},
    #   'ethusdt_1min': { epoch1: [klines], epoch2: [klines]}
    # }
    @klines = Hash.new do |hash, key|
      hash[key] = {}
    end

    @dispatche_thread = Thread.new do
      dispatch_klines
    end
  end

  # 获取或更新指定一个币或多个币的一种或多种类型的K线
  # @param symbol_or_arr [String, Array<String>] 单个symbol或者symbol数组
  # @param type [Nil, String] 值为nil或%w[1min 5min 15min 30min 60min 1day 1week]之一
  def fetch_klines(symbol_or_arr, type = nil)
    symbols = Array(symbol_or_arr)
    types = type.nil? ? %w[1min 5min 15min 30min 60min 1day 1week] : [type]

    x = ->(symbol, type) {
      # 已保存的最后一组K线起始时间
      from = nil
      latest = nil # 最后一组K线的最后一根K线
      DB.open(symbol, type, 'r') do |db|
        from = db["max_key"] # 获取目前最大的key
        latest = from.nil? ? nil : db[from][-1][:id]
        # p [symbol, type, from, latest, Time.now.strftime("%F %T.%3N")]
      end

      # 如果当前已保存的K线是最新的，则不重新获取
      return if latest != nil and Time.now.to_i < latest + distance(type)

      reqs = kline.gen_coin_all_reqs(symbol, type, from: from)
      size = reqs.size
      kline.req_klines_by_reqs(reqs)

      # 请求获取K线后，等待获取完所有K线数据后，将K线保存起来
      Async do |subtask|
        key = "#{symbol}_#{type}"

        until klines[key].size == size
          p "#{symbol} size: #{klines[key].size}/#{size}, waiting to save"
          subtask.sleep 1
        end

        DB.open(symbol, type) do |db|
          klines[key].keys
                     .sort
                     .each do |start_epoch|
            # klines[key].each do |start_epoch, data|
            data = klines[key][start_epoch]
            # 避免所有循环长时间占用CPU，主动放弃本次执行机会，每次循环单独等待被调度
            subtask.yield

            # 保存数据(epoch和对应K线)
            db.save(start_epoch, data)
            # 保存当前所有已保存的最新key
            p [symbol, data[-1][:id]]
            db.save('max_epoch', data[-1][:id])
            # db['max_epoch'] = data[-1][:id]
            db["max_key"] = start_epoch if start_epoch > db["max_key"].to_i
            db['keys'] = (db['keys'] || []).push(start_epoch).uniq

            klines[key].delete start_epoch
            puts "fetched: [#{symbol}, #{type}, #{start_epoch}, #{data.size}]"
          end
        end
      end
    }

    symbols.product(types).each_slice(10).each do |some_pairs|
      Async do |task|
        some_pairs.each do |symbol, type|
          # p [symbol, type, Time.now.strftime("%F %T.%3N")]
          x.call(symbol, type)
        end
      end
    end

    # symbols.each do |symbol|
    #   types.each do |t|
    #     x.call(symbol, t)
    #   end
    # end
  end

  private def dispatch_klines
    queue = kline.queue

    # 处理一次性请求的K线价格数据
    # {
    #   id: "btcusdt"
    #   rep: "market.btcusdt.kline.1min"
    #   status: "ok"
    #   ts: 1616681203184
    #   data: [
    #     {    // 这是第60分钟前的K线数据
    #       amount: 47.58869897859039
    #       close: 50989.63
    #       count: 1327
    #       high: 51129.91
    #       id: 1616677620  // 该K线的起始时间点(秒级epoch)
    #       low: 50986
    #       open: 51125
    #       vol: 2430238.6246752427
    #     },
    #     ... // 第59分钟前、第58分钟前...1分钟前前以及当前所在分钟的K线数据
    #   ]
    # }
    dispatcher = ->(data) {
      symbol = data[:id]
      period = data[:rep].split(".")[-1]
      klines_epoch = data[:data][0][:id] # 第一根K线的epoch时间点
      klines["#{symbol}_#{period}"][klines_epoch] = data[:data]
    }

    Async(annotation: 'call dispatcher') do |task|
      while true
        dispatcher.call(queue.shift) while queue.any?
        task.sleep 0.05
      end
    end
  end

  private def distance(type)
    case type
    when '1min' then
      60 # 60
    when '5min' then
      300 # 5 * 60
    when '15min' then
      900 # 15 * 60
    when '30min' then
      1800 # 30 * 60
    when '60min' then
      3600 # 60 * 60
    when '1day' then
      86400 # 24 * 60 * 60
    when '1week' then
      604800 # 7 * 24 * 60 * 60
    end
  end
end

def opt_parse
  options = {}
  parser = OptionParser.new do |opts|
    opts.banner = "Usage: #{File.basename $0} [options]"

    opts.separator ""
    opts.separator "Options"

    opts.on('-s symbols', '--symbols symbols', 'which symbols klines to fetch', '("btc,eth,doge")') do |symbols|
      options[:symbols] = symbols.split(',')
    end

    opts.on('-t type', '--type type', 'which type to fetch', '(1min 5min 15min 30min 60min 1day 1week)') do |type|
      (puts "invalid type", "", opts; exit) unless %w(1min 5min 15min 30min 60min 1day 1week).include? type
      options[:type] = type
    end

    opts.on('--console', 'open console') do
      options[:console] = true
    end

    opts.on('--debug', "debug mode") do
      options[:debug] = true
    end

    opts.on('--help', 'print help message') do
      puts opts
      exit
    end
  end

  parser.parse!

  if options[:console].nil?
    (puts "ArgumentsError: missing -s", "", parser; exit) if options[:symbols].nil?
    (puts "ArgumentsError: missing -t", "", parser; exit) if options[:type].nil?
  end

  if ARGV.any?
    (puts "extra arguments: #{ARGV}", "", parser; exit)
  end

  options
end

def main
  options = opt_parse

  HuobiApi.configure do |config|
    config.proxy = ENV['proxy'] || ENV['http_proxy'] || ENV['HTTP_PROXY']
    config.access_key = ENV["HUOBI_ACCESS_KEY"]
    config.secret_key = ENV["HUOBI_SECRET_KEY"]

    # config.log_file = STDOUT
    # config.log_file = 'a.log'
    config.log_level = options[:debug] ? 'debug' : 'info'

    ############## init...
    HuobiApi::Account.account_id
    HuobiApi::Coins.all_coins_info
  end

  if options[:console]
    require "irb"
    IRB.start(__FILE__)
  else
    symbols = options[:symbols]
    if symbols[0] == 'all'
      symbols = HuobiApi::Coins.all_symbols
    else
      symbols = symbols.map { |x| x.end_with?("usdt") ? x : x + "usdt" }
      symbols = symbols & HuobiApi::Coins.all_symbols
    end
    KlinesDB.fetch_klines(symbols, options[:type])
  end
end

main

# require "irb"
# IRB.start(__FILE__)

# kline_db = KlinesDB.new
# kline_db.fetch_klines(HuobiApi::Coins.all_symbols, '5min')







